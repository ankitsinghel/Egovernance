"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/parseley";
exports.ids = ["vendor-chunks/parseley"];
exports.modules = {

/***/ "(rsc)/./node_modules/parseley/lib/parseley.mjs":
/*!************************************************!*\
  !*** ./node_modules/parseley/lib/parseley.mjs ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Ast: () => (/* binding */ ast),\n/* harmony export */   compareSelectors: () => (/* binding */ compareSelectors),\n/* harmony export */   compareSpecificity: () => (/* binding */ compareSpecificity),\n/* harmony export */   normalize: () => (/* binding */ normalize),\n/* harmony export */   parse: () => (/* binding */ parse),\n/* harmony export */   parse1: () => (/* binding */ parse1),\n/* harmony export */   serialize: () => (/* binding */ serialize)\n/* harmony export */ });\n/* harmony import */ var leac__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leac */ \"(rsc)/./node_modules/leac/lib/leac.mjs\");\n/* harmony import */ var peberminta__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! peberminta */ \"(rsc)/./node_modules/peberminta/lib/core.mjs\");\n\n\n\nvar ast = /*#__PURE__*/Object.freeze({\n    __proto__: null\n});\n\nconst lex = (0,leac__WEBPACK_IMPORTED_MODULE_0__.createLexer)([\n    { name: 'ws', regex: /[ \\t\\r\\n\\f]+/ },\n    { name: 'idn', regex: /[a-zA-Z_-][a-zA-Z0-9_-]*/ },\n    { name: '#id', regex: /#[a-zA-Z0-9_-]+/ },\n    { name: 'str1', regex: /'(?:\\\\['\\\\]|[^\\n'\\\\])*'/ },\n    { name: 'str2', regex: /\"(?:\\\\[\"\\\\]|[^\\n\"\\\\])*\"/ },\n    { name: '*' },\n    { name: '.' },\n    { name: ',' },\n    { name: '[' },\n    { name: ']' },\n    { name: '=' },\n    { name: '>' },\n    { name: '|' },\n    { name: '+' },\n    { name: '~' },\n    { name: '^' },\n    { name: '$' },\n]);\nfunction sumSpec([a0, a1, a2], [b0, b1, b2]) {\n    return [a0 + b0, a1 + b1, a2 + b2];\n}\nfunction sumAllSpec(ss) {\n    return ss.reduce(sumSpec, [0, 0, 0]);\n}\nfunction literal(name) {\n    return peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => t.name === name ? true : undefined);\n}\nconst whitespace_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => t.name === 'ws' ? null : undefined);\nconst optionalWhitespace_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.option(whitespace_, null);\nfunction optionallySpaced(parser) {\n    return peberminta__WEBPACK_IMPORTED_MODULE_1__.middle(optionalWhitespace_, parser, optionalWhitespace_);\n}\nconst identifier_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => t.name === 'idn' ? t.text : undefined);\nconst hashId_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => t.name === '#id' ? t.text.slice(1) : undefined);\nconst string_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => t.name.startsWith('str') ? t.text.slice(1, -1) : undefined);\nconst namespace_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.left(peberminta__WEBPACK_IMPORTED_MODULE_1__.option(identifier_, ''), literal('|'));\nconst qualifiedName_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(namespace_, identifier_, (ns, name) => ({ name: name, namespace: ns })), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(identifier_, (name) => ({ name: name, namespace: null })));\nconst uniSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(namespace_, literal('*'), (ns) => ({ type: 'universal', namespace: ns, specificity: [0, 0, 0] })), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(literal('*'), () => ({ type: 'universal', namespace: null, specificity: [0, 0, 0] })));\nconst tagSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.map(qualifiedName_, ({ name, namespace }) => ({\n    type: 'tag',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 0, 1]\n}));\nconst classSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('.'), identifier_, (fullstop, name) => ({\n    type: 'class',\n    name: name,\n    specificity: [0, 1, 0]\n}));\nconst idSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.map(hashId_, (name) => ({\n    type: 'id',\n    name: name,\n    specificity: [1, 0, 0]\n}));\nconst attrModifier_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.token((t) => {\n    if (t.name === 'idn') {\n        if (t.text === 'i' || t.text === 'I') {\n            return 'i';\n        }\n        if (t.text === 's' || t.text === 'S') {\n            return 's';\n        }\n    }\n    return undefined;\n});\nconst attrValue_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(string_, peberminta__WEBPACK_IMPORTED_MODULE_1__.option(peberminta__WEBPACK_IMPORTED_MODULE_1__.right(optionalWhitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(identifier_, peberminta__WEBPACK_IMPORTED_MODULE_1__.option(peberminta__WEBPACK_IMPORTED_MODULE_1__.right(whitespace_, attrModifier_), null), (v, mod) => ({ value: v, modifier: mod })));\nconst attrMatcher_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.choice(peberminta__WEBPACK_IMPORTED_MODULE_1__.map(literal('='), () => '='), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('~'), literal('='), () => '~='), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('|'), literal('='), () => '|='), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('^'), literal('='), () => '^='), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('$'), literal('='), () => '$='), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('*'), literal('='), () => '*='));\nconst attrPresenceSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.abc(literal('['), optionallySpaced(qualifiedName_), literal(']'), (lbr, { name, namespace }) => ({\n    type: 'attrPresence',\n    name: name,\n    namespace: namespace,\n    specificity: [0, 1, 0]\n}));\nconst attrValueSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.middle(literal('['), peberminta__WEBPACK_IMPORTED_MODULE_1__.abc(optionallySpaced(qualifiedName_), attrMatcher_, optionallySpaced(attrValue_), ({ name, namespace }, matcher, { value, modifier }) => ({\n    type: 'attrValue',\n    name: name,\n    namespace: namespace,\n    matcher: matcher,\n    value: value,\n    modifier: modifier,\n    specificity: [0, 1, 0]\n})), literal(']'));\nconst attrSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(attrPresenceSelector_, attrValueSelector_);\nconst typeSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(uniSelector_, tagSelector_);\nconst subclassSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.choice(idSelector_, classSelector_, attrSelector_);\nconst compoundSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.map(peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(peberminta__WEBPACK_IMPORTED_MODULE_1__.flatten(typeSelector_, peberminta__WEBPACK_IMPORTED_MODULE_1__.many(subclassSelector_)), peberminta__WEBPACK_IMPORTED_MODULE_1__.many1(subclassSelector_)), (ss) => {\n    return {\n        type: 'compound',\n        list: ss,\n        specificity: sumAllSpec(ss.map(s => s.specificity))\n    };\n});\nconst combinator_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.choice(peberminta__WEBPACK_IMPORTED_MODULE_1__.map(literal('>'), () => '>'), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(literal('+'), () => '+'), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(literal('~'), () => '~'), peberminta__WEBPACK_IMPORTED_MODULE_1__.ab(literal('|'), literal('|'), () => '||'));\nconst combinatorSeparator_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.eitherOr(optionallySpaced(combinator_), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(whitespace_, () => ' '));\nconst complexSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.leftAssoc2(compoundSelector_, peberminta__WEBPACK_IMPORTED_MODULE_1__.map(combinatorSeparator_, (c) => (left, right) => ({\n    type: 'compound',\n    list: [...right.list, { type: 'combinator', combinator: c, left: left, specificity: left.specificity }],\n    specificity: sumSpec(left.specificity, right.specificity)\n})), compoundSelector_);\nconst listSelector_ = peberminta__WEBPACK_IMPORTED_MODULE_1__.leftAssoc2(peberminta__WEBPACK_IMPORTED_MODULE_1__.map(complexSelector_, (s) => ({ type: 'list', list: [s] })), peberminta__WEBPACK_IMPORTED_MODULE_1__.map(optionallySpaced(literal(',')), () => (acc, next) => ({ type: 'list', list: [...acc.list, next] })), complexSelector_);\nfunction parse_(parser, str) {\n    const lexerResult = lex(str);\n    if (!lexerResult.complete) {\n        throw new Error(`The input \"${str}\" was only partially tokenized, stopped at offset ${lexerResult.offset}!\\n` +\n            prettyPrintPosition(str, lexerResult.offset));\n    }\n    const result = optionallySpaced(parser)({ tokens: lexerResult.tokens, options: undefined }, 0);\n    if (!result.matched) {\n        throw new Error(`No match for \"${str}\" input!`);\n    }\n    if (result.position < lexerResult.tokens.length) {\n        const token = lexerResult.tokens[result.position];\n        throw new Error(`The input \"${str}\" was only partially parsed, stopped at offset ${token.offset}!\\n` +\n            prettyPrintPosition(str, token.offset, token.len));\n    }\n    return result.value;\n}\nfunction prettyPrintPosition(str, offset, len = 1) {\n    return `${str.replace(/(\\t)|(\\r)|(\\n)/g, (m, t, r) => t ? '\\u2409' : r ? '\\u240d' : '\\u240a')}\\n${''.padEnd(offset)}${'^'.repeat(len)}`;\n}\nfunction parse(str) {\n    return parse_(listSelector_, str);\n}\nfunction parse1(str) {\n    return parse_(complexSelector_, str);\n}\n\nfunction serialize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'universal':\n            return _serNs(selector.namespace) + '*';\n        case 'tag':\n            return _serNs(selector.namespace) + selector.name;\n        case 'class':\n            return '.' + selector.name;\n        case 'id':\n            return '#' + selector.name;\n        case 'attrPresence':\n            return `[${_serNs(selector.namespace)}${selector.name}]`;\n        case 'attrValue':\n            return `[${_serNs(selector.namespace)}${selector.name}${selector.matcher}${_serStr(selector.value)}${(selector.modifier ? selector.modifier : '')}]`;\n        case 'combinator':\n            return serialize(selector.left) + selector.combinator;\n        case 'compound':\n            return selector.list.reduce((acc, node) => {\n                if (node.type === 'combinator') {\n                    return serialize(node) + acc;\n                }\n                else {\n                    return acc + serialize(node);\n                }\n            }, '');\n        case 'list':\n            return selector.list.map(serialize).join(',');\n    }\n}\nfunction _serNs(ns) {\n    return (ns || ns === '')\n        ? ns + '|'\n        : '';\n}\nfunction _serStr(str) {\n    if (str.indexOf('\"') === -1) {\n        return `\"${str}\"`;\n    }\n    else if (str.indexOf(\"'\") === -1) {\n        return `'${str}'`;\n    }\n    else {\n        return `\"${str.replace('\"', '\\\\\"')}\"`;\n    }\n}\nfunction normalize(selector) {\n    if (!selector.type) {\n        throw new Error('This is not an AST node.');\n    }\n    switch (selector.type) {\n        case 'compound': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => _compareArrays(_getSelectorPriority(a), _getSelectorPriority(b)));\n            break;\n        }\n        case 'combinator': {\n            normalize(selector.left);\n            break;\n        }\n        case 'list': {\n            selector.list.forEach(normalize);\n            selector.list.sort((a, b) => (serialize(a) < serialize(b)) ? -1 : 1);\n            break;\n        }\n    }\n    return selector;\n}\nfunction _getSelectorPriority(selector) {\n    switch (selector.type) {\n        case 'universal':\n            return [1];\n        case 'tag':\n            return [1];\n        case 'id':\n            return [2];\n        case 'class':\n            return [3, selector.name];\n        case 'attrPresence':\n            return [4, serialize(selector)];\n        case 'attrValue':\n            return [5, serialize(selector)];\n        case 'combinator':\n            return [15, serialize(selector)];\n    }\n}\nfunction compareSelectors(a, b) {\n    return _compareArrays(a.specificity, b.specificity);\n}\nfunction compareSpecificity(a, b) {\n    return _compareArrays(a, b);\n}\nfunction _compareArrays(a, b) {\n    if (!Array.isArray(a) || !Array.isArray(b)) {\n        throw new Error('Arguments must be arrays.');\n    }\n    const shorter = (a.length < b.length) ? a.length : b.length;\n    for (let i = 0; i < shorter; i++) {\n        if (a[i] === b[i]) {\n            continue;\n        }\n        return (a[i] < b[i]) ? -1 : 1;\n    }\n    return a.length - b.length;\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGFyc2VsZXkvbGliL3BhcnNlbGV5Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUM7QUFDSDs7QUFFaEM7QUFDQTtBQUNBLENBQUM7O0FBRUQsWUFBWSxpREFBVztBQUN2QixNQUFNLG1DQUFtQztBQUN6QyxNQUFNLGdEQUFnRDtBQUN0RCxNQUFNLHVDQUF1QztBQUM3QyxNQUFNLGdEQUFnRDtBQUN0RCxNQUFNLGdEQUFnRDtBQUN0RCxNQUFNLFdBQVc7QUFDakIsTUFBTSxXQUFXO0FBQ2pCLE1BQU0sV0FBVztBQUNqQixNQUFNLFdBQVc7QUFDakIsTUFBTSxXQUFXO0FBQ2pCLE1BQU0sV0FBVztBQUNqQixNQUFNLFdBQVc7QUFDakIsTUFBTSxXQUFXO0FBQ2pCLE1BQU0sV0FBVztBQUNqQixNQUFNLFdBQVc7QUFDakIsTUFBTSxXQUFXO0FBQ2pCLE1BQU0sV0FBVztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw2Q0FBTztBQUNsQjtBQUNBLG9CQUFvQiw2Q0FBTztBQUMzQiw0QkFBNEIsOENBQVE7QUFDcEM7QUFDQSxXQUFXLDhDQUFRO0FBQ25CO0FBQ0Esb0JBQW9CLDZDQUFPO0FBQzNCLGdCQUFnQiw2Q0FBTztBQUN2QixnQkFBZ0IsNkNBQU87QUFDdkIsbUJBQW1CLDRDQUFNLENBQUMsOENBQVE7QUFDbEMsdUJBQXVCLGdEQUFVLENBQUMsMENBQUksMkNBQTJDLDJCQUEyQixJQUFJLDJDQUFLLDJCQUEyQiw2QkFBNkI7QUFDN0sscUJBQXFCLGdEQUFVLENBQUMsMENBQUksc0NBQXNDLDBEQUEwRCxJQUFJLDJDQUFLLHdCQUF3Qiw0REFBNEQ7QUFDak8scUJBQXFCLDJDQUFLLG9CQUFvQixpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsdUJBQXVCLDBDQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxvQkFBb0IsMkNB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QUNBOztBQUVpRyIsInNvdXJjZXMiOlsiRDpcXENvZGVzXFxoYWNrYXRob25cXG5vZGVfbW9kdWxlc1xccGFyc2VsZXlcXGxpYlxccGFyc2VsZXkubWpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUxleGVyIH0gZnJvbSAnbGVhYyc7XG5pbXBvcnQgKiBhcyBwIGZyb20gJ3BlYmVybWludGEnO1xuXG52YXIgYXN0ID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICAgIF9fcHJvdG9fXzogbnVsbFxufSk7XG5cbmNvbnN0IGxleCA9IGNyZWF0ZUxleGVyKFtcbiAgICB7IG5hbWU6ICd3cycsIHJlZ2V4OiAvWyBcXHRcXHJcXG5cXGZdKy8gfSxcbiAgICB7IG5hbWU6ICdpZG4nLCByZWdleDogL1thLXpBLVpfLV1bYS16QS1aMC05Xy1dKi8gfSxcbiAgICB7IG5hbWU6ICcjaWQnLCByZWdleDogLyNbYS16QS1aMC05Xy1dKy8gfSxcbiAgICB7IG5hbWU6ICdzdHIxJywgcmVnZXg6IC8nKD86XFxcXFsnXFxcXF18W15cXG4nXFxcXF0pKicvIH0sXG4gICAgeyBuYW1lOiAnc3RyMicsIHJlZ2V4OiAvXCIoPzpcXFxcW1wiXFxcXF18W15cXG5cIlxcXFxdKSpcIi8gfSxcbiAgICB7IG5hbWU6ICcqJyB9LFxuICAgIHsgbmFtZTogJy4nIH0sXG4gICAgeyBuYW1lOiAnLCcgfSxcbiAgICB7IG5hbWU6ICdbJyB9LFxuICAgIHsgbmFtZTogJ10nIH0sXG4gICAgeyBuYW1lOiAnPScgfSxcbiAgICB7IG5hbWU6ICc+JyB9LFxuICAgIHsgbmFtZTogJ3wnIH0sXG4gICAgeyBuYW1lOiAnKycgfSxcbiAgICB7IG5hbWU6ICd+JyB9LFxuICAgIHsgbmFtZTogJ14nIH0sXG4gICAgeyBuYW1lOiAnJCcgfSxcbl0pO1xuZnVuY3Rpb24gc3VtU3BlYyhbYTAsIGExLCBhMl0sIFtiMCwgYjEsIGIyXSkge1xuICAgIHJldHVybiBbYTAgKyBiMCwgYTEgKyBiMSwgYTIgKyBiMl07XG59XG5mdW5jdGlvbiBzdW1BbGxTcGVjKHNzKSB7XG4gICAgcmV0dXJuIHNzLnJlZHVjZShzdW1TcGVjLCBbMCwgMCwgMF0pO1xufVxuZnVuY3Rpb24gbGl0ZXJhbChuYW1lKSB7XG4gICAgcmV0dXJuIHAudG9rZW4oKHQpID0+IHQubmFtZSA9PT0gbmFtZSA/IHRydWUgOiB1bmRlZmluZWQpO1xufVxuY29uc3Qgd2hpdGVzcGFjZV8gPSBwLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICd3cycgPyBudWxsIDogdW5kZWZpbmVkKTtcbmNvbnN0IG9wdGlvbmFsV2hpdGVzcGFjZV8gPSBwLm9wdGlvbih3aGl0ZXNwYWNlXywgbnVsbCk7XG5mdW5jdGlvbiBvcHRpb25hbGx5U3BhY2VkKHBhcnNlcikge1xuICAgIHJldHVybiBwLm1pZGRsZShvcHRpb25hbFdoaXRlc3BhY2VfLCBwYXJzZXIsIG9wdGlvbmFsV2hpdGVzcGFjZV8pO1xufVxuY29uc3QgaWRlbnRpZmllcl8gPSBwLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICdpZG4nID8gdC50ZXh0IDogdW5kZWZpbmVkKTtcbmNvbnN0IGhhc2hJZF8gPSBwLnRva2VuKCh0KSA9PiB0Lm5hbWUgPT09ICcjaWQnID8gdC50ZXh0LnNsaWNlKDEpIDogdW5kZWZpbmVkKTtcbmNvbnN0IHN0cmluZ18gPSBwLnRva2VuKCh0KSA9PiB0Lm5hbWUuc3RhcnRzV2l0aCgnc3RyJykgPyB0LnRleHQuc2xpY2UoMSwgLTEpIDogdW5kZWZpbmVkKTtcbmNvbnN0IG5hbWVzcGFjZV8gPSBwLmxlZnQocC5vcHRpb24oaWRlbnRpZmllcl8sICcnKSwgbGl0ZXJhbCgnfCcpKTtcbmNvbnN0IHF1YWxpZmllZE5hbWVfID0gcC5laXRoZXJPcihwLmFiKG5hbWVzcGFjZV8sIGlkZW50aWZpZXJfLCAobnMsIG5hbWUpID0+ICh7IG5hbWU6IG5hbWUsIG5hbWVzcGFjZTogbnMgfSkpLCBwLm1hcChpZGVudGlmaWVyXywgKG5hbWUpID0+ICh7IG5hbWU6IG5hbWUsIG5hbWVzcGFjZTogbnVsbCB9KSkpO1xuY29uc3QgdW5pU2VsZWN0b3JfID0gcC5laXRoZXJPcihwLmFiKG5hbWVzcGFjZV8sIGxpdGVyYWwoJyonKSwgKG5zKSA9PiAoeyB0eXBlOiAndW5pdmVyc2FsJywgbmFtZXNwYWNlOiBucywgc3BlY2lmaWNpdHk6IFswLCAwLCAwXSB9KSksIHAubWFwKGxpdGVyYWwoJyonKSwgKCkgPT4gKHsgdHlwZTogJ3VuaXZlcnNhbCcsIG5hbWVzcGFjZTogbnVsbCwgc3BlY2lmaWNpdHk6IFswLCAwLCAwXSB9KSkpO1xuY29uc3QgdGFnU2VsZWN0b3JfID0gcC5tYXAocXVhbGlmaWVkTmFtZV8sICh7IG5hbWUsIG5hbWVzcGFjZSB9KSA9PiAoe1xuICAgIHR5cGU6ICd0YWcnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAwLCAxXVxufSkpO1xuY29uc3QgY2xhc3NTZWxlY3Rvcl8gPSBwLmFiKGxpdGVyYWwoJy4nKSwgaWRlbnRpZmllcl8sIChmdWxsc3RvcCwgbmFtZSkgPT4gKHtcbiAgICB0eXBlOiAnY2xhc3MnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAxLCAwXVxufSkpO1xuY29uc3QgaWRTZWxlY3Rvcl8gPSBwLm1hcChoYXNoSWRfLCAobmFtZSkgPT4gKHtcbiAgICB0eXBlOiAnaWQnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgc3BlY2lmaWNpdHk6IFsxLCAwLCAwXVxufSkpO1xuY29uc3QgYXR0ck1vZGlmaWVyXyA9IHAudG9rZW4oKHQpID0+IHtcbiAgICBpZiAodC5uYW1lID09PSAnaWRuJykge1xuICAgICAgICBpZiAodC50ZXh0ID09PSAnaScgfHwgdC50ZXh0ID09PSAnSScpIHtcbiAgICAgICAgICAgIHJldHVybiAnaSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHQudGV4dCA9PT0gJ3MnIHx8IHQudGV4dCA9PT0gJ1MnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3MnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB1bmRlZmluZWQ7XG59KTtcbmNvbnN0IGF0dHJWYWx1ZV8gPSBwLmVpdGhlck9yKHAuYWIoc3RyaW5nXywgcC5vcHRpb24ocC5yaWdodChvcHRpb25hbFdoaXRlc3BhY2VfLCBhdHRyTW9kaWZpZXJfKSwgbnVsbCksICh2LCBtb2QpID0+ICh7IHZhbHVlOiB2LCBtb2RpZmllcjogbW9kIH0pKSwgcC5hYihpZGVudGlmaWVyXywgcC5vcHRpb24ocC5yaWdodCh3aGl0ZXNwYWNlXywgYXR0ck1vZGlmaWVyXyksIG51bGwpLCAodiwgbW9kKSA9PiAoeyB2YWx1ZTogdiwgbW9kaWZpZXI6IG1vZCB9KSkpO1xuY29uc3QgYXR0ck1hdGNoZXJfID0gcC5jaG9pY2UocC5tYXAobGl0ZXJhbCgnPScpLCAoKSA9PiAnPScpLCBwLmFiKGxpdGVyYWwoJ34nKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnfj0nKSwgcC5hYihsaXRlcmFsKCd8JyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJ3w9JyksIHAuYWIobGl0ZXJhbCgnXicpLCBsaXRlcmFsKCc9JyksICgpID0+ICdePScpLCBwLmFiKGxpdGVyYWwoJyQnKSwgbGl0ZXJhbCgnPScpLCAoKSA9PiAnJD0nKSwgcC5hYihsaXRlcmFsKCcqJyksIGxpdGVyYWwoJz0nKSwgKCkgPT4gJyo9JykpO1xuY29uc3QgYXR0clByZXNlbmNlU2VsZWN0b3JfID0gcC5hYmMobGl0ZXJhbCgnWycpLCBvcHRpb25hbGx5U3BhY2VkKHF1YWxpZmllZE5hbWVfKSwgbGl0ZXJhbCgnXScpLCAobGJyLCB7IG5hbWUsIG5hbWVzcGFjZSB9KSA9PiAoe1xuICAgIHR5cGU6ICdhdHRyUHJlc2VuY2UnLFxuICAgIG5hbWU6IG5hbWUsXG4gICAgbmFtZXNwYWNlOiBuYW1lc3BhY2UsXG4gICAgc3BlY2lmaWNpdHk6IFswLCAxLCAwXVxufSkpO1xuY29uc3QgYXR0clZhbHVlU2VsZWN0b3JfID0gcC5taWRkbGUobGl0ZXJhbCgnWycpLCBwLmFiYyhvcHRpb25hbGx5U3BhY2VkKHF1YWxpZmllZE5hbWVfKSwgYXR0ck1hdGNoZXJfLCBvcHRpb25hbGx5U3BhY2VkKGF0dHJWYWx1ZV8pLCAoeyBuYW1lLCBuYW1lc3BhY2UgfSwgbWF0Y2hlciwgeyB2YWx1ZSwgbW9kaWZpZXIgfSkgPT4gKHtcbiAgICB0eXBlOiAnYXR0clZhbHVlJyxcbiAgICBuYW1lOiBuYW1lLFxuICAgIG5hbWVzcGFjZTogbmFtZXNwYWNlLFxuICAgIG1hdGNoZXI6IG1hdGNoZXIsXG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIG1vZGlmaWVyOiBtb2RpZmllcixcbiAgICBzcGVjaWZpY2l0eTogWzAsIDEsIDBdXG59KSksIGxpdGVyYWwoJ10nKSk7XG5jb25zdCBhdHRyU2VsZWN0b3JfID0gcC5laXRoZXJPcihhdHRyUHJlc2VuY2VTZWxlY3Rvcl8sIGF0dHJWYWx1ZVNlbGVjdG9yXyk7XG5jb25zdCB0eXBlU2VsZWN0b3JfID0gcC5laXRoZXJPcih1bmlTZWxlY3Rvcl8sIHRhZ1NlbGVjdG9yXyk7XG5jb25zdCBzdWJjbGFzc1NlbGVjdG9yXyA9IHAuY2hvaWNlKGlkU2VsZWN0b3JfLCBjbGFzc1NlbGVjdG9yXywgYXR0clNlbGVjdG9yXyk7XG5jb25zdCBjb21wb3VuZFNlbGVjdG9yXyA9IHAubWFwKHAuZWl0aGVyT3IocC5mbGF0dGVuKHR5cGVTZWxlY3Rvcl8sIHAubWFueShzdWJjbGFzc1NlbGVjdG9yXykpLCBwLm1hbnkxKHN1YmNsYXNzU2VsZWN0b3JfKSksIChzcykgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdjb21wb3VuZCcsXG4gICAgICAgIGxpc3Q6IHNzLFxuICAgICAgICBzcGVjaWZpY2l0eTogc3VtQWxsU3BlYyhzcy5tYXAocyA9PiBzLnNwZWNpZmljaXR5KSlcbiAgICB9O1xufSk7XG5jb25zdCBjb21iaW5hdG9yXyA9IHAuY2hvaWNlKHAubWFwKGxpdGVyYWwoJz4nKSwgKCkgPT4gJz4nKSwgcC5tYXAobGl0ZXJhbCgnKycpLCAoKSA9PiAnKycpLCBwLm1hcChsaXRlcmFsKCd+JyksICgpID0+ICd+JyksIHAuYWIobGl0ZXJhbCgnfCcpLCBsaXRlcmFsKCd8JyksICgpID0+ICd8fCcpKTtcbmNvbnN0IGNvbWJpbmF0b3JTZXBhcmF0b3JfID0gcC5laXRoZXJPcihvcHRpb25hbGx5U3BhY2VkKGNvbWJpbmF0b3JfKSwgcC5tYXAod2hpdGVzcGFjZV8sICgpID0+ICcgJykpO1xuY29uc3QgY29tcGxleFNlbGVjdG9yXyA9IHAubGVmdEFzc29jMihjb21wb3VuZFNlbGVjdG9yXywgcC5tYXAoY29tYmluYXRvclNlcGFyYXRvcl8sIChjKSA9PiAobGVmdCwgcmlnaHQpID0+ICh7XG4gICAgdHlwZTogJ2NvbXBvdW5kJyxcbiAgICBsaXN0OiBbLi4ucmlnaHQubGlzdCwgeyB0eXBlOiAnY29tYmluYXRvcicsIGNvbWJpbmF0b3I6IGMsIGxlZnQ6IGxlZnQsIHNwZWNpZmljaXR5OiBsZWZ0LnNwZWNpZmljaXR5IH1dLFxuICAgIHNwZWNpZmljaXR5OiBzdW1TcGVjKGxlZnQuc3BlY2lmaWNpdHksIHJpZ2h0LnNwZWNpZmljaXR5KVxufSkpLCBjb21wb3VuZFNlbGVjdG9yXyk7XG5jb25zdCBsaXN0U2VsZWN0b3JfID0gcC5sZWZ0QXNzb2MyKHAubWFwKGNvbXBsZXhTZWxlY3Rvcl8sIChzKSA9PiAoeyB0eXBlOiAnbGlzdCcsIGxpc3Q6IFtzXSB9KSksIHAubWFwKG9wdGlvbmFsbHlTcGFjZWQobGl0ZXJhbCgnLCcpKSwgKCkgPT4gKGFjYywgbmV4dCkgPT4gKHsgdHlwZTogJ2xpc3QnLCBsaXN0OiBbLi4uYWNjLmxpc3QsIG5leHRdIH0pKSwgY29tcGxleFNlbGVjdG9yXyk7XG5mdW5jdGlvbiBwYXJzZV8ocGFyc2VyLCBzdHIpIHtcbiAgICBjb25zdCBsZXhlclJlc3VsdCA9IGxleChzdHIpO1xuICAgIGlmICghbGV4ZXJSZXN1bHQuY29tcGxldGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBUaGUgaW5wdXQgXCIke3N0cn1cIiB3YXMgb25seSBwYXJ0aWFsbHkgdG9rZW5pemVkLCBzdG9wcGVkIGF0IG9mZnNldCAke2xleGVyUmVzdWx0Lm9mZnNldH0hXFxuYCArXG4gICAgICAgICAgICBwcmV0dHlQcmludFBvc2l0aW9uKHN0ciwgbGV4ZXJSZXN1bHQub2Zmc2V0KSk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IG9wdGlvbmFsbHlTcGFjZWQocGFyc2VyKSh7IHRva2VuczogbGV4ZXJSZXN1bHQudG9rZW5zLCBvcHRpb25zOiB1bmRlZmluZWQgfSwgMCk7XG4gICAgaWYgKCFyZXN1bHQubWF0Y2hlZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vIG1hdGNoIGZvciBcIiR7c3RyfVwiIGlucHV0IWApO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LnBvc2l0aW9uIDwgbGV4ZXJSZXN1bHQudG9rZW5zLmxlbmd0aCkge1xuICAgICAgICBjb25zdCB0b2tlbiA9IGxleGVyUmVzdWx0LnRva2Vuc1tyZXN1bHQucG9zaXRpb25dO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBpbnB1dCBcIiR7c3RyfVwiIHdhcyBvbmx5IHBhcnRpYWxseSBwYXJzZWQsIHN0b3BwZWQgYXQgb2Zmc2V0ICR7dG9rZW4ub2Zmc2V0fSFcXG5gICtcbiAgICAgICAgICAgIHByZXR0eVByaW50UG9zaXRpb24oc3RyLCB0b2tlbi5vZmZzZXQsIHRva2VuLmxlbikpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gcHJldHR5UHJpbnRQb3NpdGlvbihzdHIsIG9mZnNldCwgbGVuID0gMSkge1xuICAgIHJldHVybiBgJHtzdHIucmVwbGFjZSgvKFxcdCl8KFxccil8KFxcbikvZywgKG0sIHQsIHIpID0+IHQgPyAnXFx1MjQwOScgOiByID8gJ1xcdTI0MGQnIDogJ1xcdTI0MGEnKX1cXG4keycnLnBhZEVuZChvZmZzZXQpfSR7J14nLnJlcGVhdChsZW4pfWA7XG59XG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgICByZXR1cm4gcGFyc2VfKGxpc3RTZWxlY3Rvcl8sIHN0cik7XG59XG5mdW5jdGlvbiBwYXJzZTEoc3RyKSB7XG4gICAgcmV0dXJuIHBhcnNlXyhjb21wbGV4U2VsZWN0b3JfLCBzdHIpO1xufVxuXG5mdW5jdGlvbiBzZXJpYWxpemUoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIG5vdCBhbiBBU1Qgbm9kZS4nKTtcbiAgICB9XG4gICAgc3dpdGNoIChzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ3VuaXZlcnNhbCc6XG4gICAgICAgICAgICByZXR1cm4gX3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSkgKyAnKic7XG4gICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICByZXR1cm4gX3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSkgKyBzZWxlY3Rvci5uYW1lO1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICByZXR1cm4gJy4nICsgc2VsZWN0b3IubmFtZTtcbiAgICAgICAgY2FzZSAnaWQnOlxuICAgICAgICAgICAgcmV0dXJuICcjJyArIHNlbGVjdG9yLm5hbWU7XG4gICAgICAgIGNhc2UgJ2F0dHJQcmVzZW5jZSc6XG4gICAgICAgICAgICByZXR1cm4gYFske19zZXJOcyhzZWxlY3Rvci5uYW1lc3BhY2UpfSR7c2VsZWN0b3IubmFtZX1dYDtcbiAgICAgICAgY2FzZSAnYXR0clZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBgWyR7X3Nlck5zKHNlbGVjdG9yLm5hbWVzcGFjZSl9JHtzZWxlY3Rvci5uYW1lfSR7c2VsZWN0b3IubWF0Y2hlcn0ke19zZXJTdHIoc2VsZWN0b3IudmFsdWUpfSR7KHNlbGVjdG9yLm1vZGlmaWVyID8gc2VsZWN0b3IubW9kaWZpZXIgOiAnJyl9XWA7XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZShzZWxlY3Rvci5sZWZ0KSArIHNlbGVjdG9yLmNvbWJpbmF0b3I7XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzpcbiAgICAgICAgICAgIHJldHVybiBzZWxlY3Rvci5saXN0LnJlZHVjZSgoYWNjLCBub2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUudHlwZSA9PT0gJ2NvbWJpbmF0b3InKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUobm9kZSkgKyBhY2M7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYWNjICsgc2VyaWFsaXplKG5vZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sICcnKTtcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICByZXR1cm4gc2VsZWN0b3IubGlzdC5tYXAoc2VyaWFsaXplKS5qb2luKCcsJyk7XG4gICAgfVxufVxuZnVuY3Rpb24gX3Nlck5zKG5zKSB7XG4gICAgcmV0dXJuIChucyB8fCBucyA9PT0gJycpXG4gICAgICAgID8gbnMgKyAnfCdcbiAgICAgICAgOiAnJztcbn1cbmZ1bmN0aW9uIF9zZXJTdHIoc3RyKSB7XG4gICAgaWYgKHN0ci5pbmRleE9mKCdcIicpID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYFwiJHtzdHJ9XCJgO1xuICAgIH1cbiAgICBlbHNlIGlmIChzdHIuaW5kZXhPZihcIidcIikgPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBgJyR7c3RyfSdgO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBcIiR7c3RyLnJlcGxhY2UoJ1wiJywgJ1xcXFxcIicpfVwiYDtcbiAgICB9XG59XG5mdW5jdGlvbiBub3JtYWxpemUoc2VsZWN0b3IpIHtcbiAgICBpZiAoIXNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGlzIGlzIG5vdCBhbiBBU1Qgbm9kZS4nKTtcbiAgICB9XG4gICAgc3dpdGNoIChzZWxlY3Rvci50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2NvbXBvdW5kJzoge1xuICAgICAgICAgICAgc2VsZWN0b3IubGlzdC5mb3JFYWNoKG5vcm1hbGl6ZSk7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LnNvcnQoKGEsIGIpID0+IF9jb21wYXJlQXJyYXlzKF9nZXRTZWxlY3RvclByaW9yaXR5KGEpLCBfZ2V0U2VsZWN0b3JQcmlvcml0eShiKSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnY29tYmluYXRvcic6IHtcbiAgICAgICAgICAgIG5vcm1hbGl6ZShzZWxlY3Rvci5sZWZ0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ2xpc3QnOiB7XG4gICAgICAgICAgICBzZWxlY3Rvci5saXN0LmZvckVhY2gobm9ybWFsaXplKTtcbiAgICAgICAgICAgIHNlbGVjdG9yLmxpc3Quc29ydCgoYSwgYikgPT4gKHNlcmlhbGl6ZShhKSA8IHNlcmlhbGl6ZShiKSkgPyAtMSA6IDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNlbGVjdG9yO1xufVxuZnVuY3Rpb24gX2dldFNlbGVjdG9yUHJpb3JpdHkoc2VsZWN0b3IpIHtcbiAgICBzd2l0Y2ggKHNlbGVjdG9yLnR5cGUpIHtcbiAgICAgICAgY2FzZSAndW5pdmVyc2FsJzpcbiAgICAgICAgICAgIHJldHVybiBbMV07XG4gICAgICAgIGNhc2UgJ3RhZyc6XG4gICAgICAgICAgICByZXR1cm4gWzFdO1xuICAgICAgICBjYXNlICdpZCc6XG4gICAgICAgICAgICByZXR1cm4gWzJdO1xuICAgICAgICBjYXNlICdjbGFzcyc6XG4gICAgICAgICAgICByZXR1cm4gWzMsIHNlbGVjdG9yLm5hbWVdO1xuICAgICAgICBjYXNlICdhdHRyUHJlc2VuY2UnOlxuICAgICAgICAgICAgcmV0dXJuIFs0LCBzZXJpYWxpemUoc2VsZWN0b3IpXTtcbiAgICAgICAgY2FzZSAnYXR0clZhbHVlJzpcbiAgICAgICAgICAgIHJldHVybiBbNSwgc2VyaWFsaXplKHNlbGVjdG9yKV07XG4gICAgICAgIGNhc2UgJ2NvbWJpbmF0b3InOlxuICAgICAgICAgICAgcmV0dXJuIFsxNSwgc2VyaWFsaXplKHNlbGVjdG9yKV07XG4gICAgfVxufVxuZnVuY3Rpb24gY29tcGFyZVNlbGVjdG9ycyhhLCBiKSB7XG4gICAgcmV0dXJuIF9jb21wYXJlQXJyYXlzKGEuc3BlY2lmaWNpdHksIGIuc3BlY2lmaWNpdHkpO1xufVxuZnVuY3Rpb24gY29tcGFyZVNwZWNpZmljaXR5KGEsIGIpIHtcbiAgICByZXR1cm4gX2NvbXBhcmVBcnJheXMoYSwgYik7XG59XG5mdW5jdGlvbiBfY29tcGFyZUFycmF5cyhhLCBiKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGEpIHx8ICFBcnJheS5pc0FycmF5KGIpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJndW1lbnRzIG11c3QgYmUgYXJyYXlzLicpO1xuICAgIH1cbiAgICBjb25zdCBzaG9ydGVyID0gKGEubGVuZ3RoIDwgYi5sZW5ndGgpID8gYS5sZW5ndGggOiBiLmxlbmd0aDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNob3J0ZXI7IGkrKykge1xuICAgICAgICBpZiAoYVtpXSA9PT0gYltpXSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChhW2ldIDwgYltpXSkgPyAtMSA6IDE7XG4gICAgfVxuICAgIHJldHVybiBhLmxlbmd0aCAtIGIubGVuZ3RoO1xufVxuXG5leHBvcnQgeyBhc3QgYXMgQXN0LCBjb21wYXJlU2VsZWN0b3JzLCBjb21wYXJlU3BlY2lmaWNpdHksIG5vcm1hbGl6ZSwgcGFyc2UsIHBhcnNlMSwgc2VyaWFsaXplIH07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/parseley/lib/parseley.mjs\n");

/***/ })

};
;